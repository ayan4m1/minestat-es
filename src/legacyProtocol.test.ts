import { LegacyQueryProtocol, queryBytes } from './legacyProtocol';

export const validData = [
  Buffer.from([
    0xff, 0x00, 0x19, 0x00, 0xa7, 0x00, 0x31, 0x00, 0x00, 0x00, 0x34, 0x00,
    0x37, 0x00, 0x00, 0x00, 0x31, 0x00, 0x2e, 0x00, 0x34, 0x00, 0x2e, 0x00,
    0x32, 0x00, 0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00,
    0x72, 0x00, 0x76, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x30, 0x00,
    0x00, 0x00, 0x32, 0x00, 0x30
  ]),
  Buffer.from([
    0xff, 0x00, 0x13, 0x00, 0xa7, 0x00, 0x31, 0x00, 0x00, 0x00, 0x31, 0x00,
    0x32, 0x00, 0x37, 0x00, 0x00, 0x00, 0x31, 0x00, 0x2e, 0x00, 0x31, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x32, 0x00, 0x30
  ])
];
export const invalidPlayerData = Buffer.from([
  0xff, 0x00, 0x23, 0x00, 0xa7, 0x00, 0x31, 0x00, 0x00, 0x00, 0x34, 0x00, 0x37,
  0x00, 0x00, 0x00, 0x31, 0x00, 0x2e, 0x00, 0x34, 0x00, 0x2e, 0x00, 0x32, 0x00,
  0x00, 0x00, 0x41, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x76,
  0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x5a, 0x69
]);
export const emptyData = [undefined, Buffer.from([])];
export const invalidData = [
  Buffer.from([0xff, 0x30, 0x00]),
  Buffer.from([0xfa, 0xbe, 0xef, 0xff, 0xff, 0xff, 0xff])
];
export const shortData = Buffer.from([0xff, 0x00, 0x00]);

describe('LegacyQueryProtocol', () => {
  const protocol = new LegacyQueryProtocol();

  it('can generate a handshake packet', () => {
    const result = protocol.handshakePacket();

    expect(result.compare(queryBytes)).toBe(0);
  });

  it('can generate a ping packet', () => {
    const result = protocol.pingPacket();

    expect(result.compare(queryBytes)).toBe(0);
  });

  it.each(validData)('can parse a valid response', (data) => {
    const { online, error } = protocol.parse(data);

    expect(online).toBeTruthy();
    expect(error).toBeFalsy();
  });

  it('can handle invalid player counts', () => {
    const expectedError = new Error('Failed to parse player count numbers!');
    const { online, error } = protocol.parse(invalidPlayerData);

    expect(online).toBeFalsy();
    expect(error).toEqual(expectedError);
  });

  it.each(emptyData)('can handle an empty buffer', (data) => {
    const expectedError = new Error('Got empty reply from Minecraft server!');
    const { online, error } = protocol.parse(data);

    expect(online).toBeFalsy();
    expect(error).toEqual(expectedError);
  });

  it.each(invalidData)('can handle invalid data', (data) => {
    const expectedError = new Error('Got invalid reply from Minecraft server!');
    const { online, error } = protocol.parse(data);

    expect(online).toBeFalsy();
    expect(error).toEqual(expectedError);
  });

  it('can handle a truncated response', () => {
    const expectedError = new Error('Got short reply from Minecraft server!');
    const { online, error } = protocol.parse(shortData);

    expect(online).toBeFalsy();
    expect(error).toEqual(expectedError);
  });
});
